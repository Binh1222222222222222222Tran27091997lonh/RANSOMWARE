from Crypto.Cipher import AES 
from Crypto.Util.Padding import unpad
from Crypto.Protocol.KDF import PBKDF2
import json 
import time
import re

# Cấu hình
passphrase = b'my_strong_password'
salt = b'fixed_salt_value'
input_file = "AppData/system_cache.bin"
output_file = "decrypted_logs.txt"

# Tạo key
key = PBKDF2(passphrase, salt, dkLen=16)

# Đọc dữ liệu mã hóa
with open(input_file, "rb") as f:
    iv = f.read(16)  # IV 16 byte
    ciphertext = f.read()

# Giải mã
cipher = AES.new(key, AES.MODE_CBC, iv)
decrypted_data = cipher.decrypt(ciphertext)

# Xử lý đa đoạn JSON
def process_json_chunks(data):
    # Tách dữ liệu thành các chunk dựa trên pattern JSON
    json_chunks = []
    start = 0
    
    while start < len(data):
        try:
            # Thử bỏ padding cho chunk hiện tại
            chunk = unpad(data[start:], AES.block_size)
            # Tìm vị trí kết thúc JSON hợp lệ
            end = start + len(chunk)
            # Thử parse JSON
            json_chunks.append(json.loads(chunk))
            start = end
        except:
            # Tìm vị trí bắt đầu JSON tiếp theo
            next_start = data.find(b'[', start + 1)
            if next_start == -1:
                break
            start = next_start

    return json_chunks

# Xử lý dữ liệu
all_entries = []
try:
    # Phương pháp 1: Xử lý các chunk JSON riêng biệt
    json_chunks = process_json_chunks(decrypted_data)
    
    # Gom tất cả entry vào một mảng
    for chunk in json_chunks:
        if isinstance(chunk, list):
            all_entries.extend(chunk)
        else:
            all_entries.append(chunk)
    
except Exception as e:
    print(f"Lỗi xử lý chunk: {e}")
    all_entries = []
    
    # Phương pháp 2: Khôi phục thủ công từ dữ liệu thô
    try:
        raw_text = decrypted_data.decode('utf-8', errors='ignore')
        # Sử dụng regex để tìm các mảng JSON
        json_matches = re.findall(r'\[.*?\]', raw_text, re.DOTALL)
        
        for match in json_matches:
            try:
                entries = json.loads(match)
                if isinstance(entries, list):
                    all_entries.extend(entries)
                else:
                    all_entries.append(entries)
            except:
                continue
    except Exception as e2:
        print(f"Lỗi khôi phục thủ công: {e2}")

# Ghi kết quả
if all_entries:
    with open(output_file, "w", encoding="utf-8") as f:
        for entry in all_entries:
            try:
                ts = time.localtime(entry['timestamp'])
                timestamp = time.strftime("%Y-%m-%d %H:%M:%S", ts)
                f.write(f"[{timestamp}] [{entry['type']}] {entry['data']}\n")
            except:
                f.write(f"[INVALID ENTRY] {str(entry)[:200]}\n")
    print(f"Đã ghi {len(all_entries)} log entries")
else:
    # Fallback cuối cùng: ghi dữ liệu thô
    with open(output_file, "wb") as f:
        f.write(decrypted_data)
    print(f"Không thể parse JSON. Đã lưu dữ liệu thô vào {output_file}")